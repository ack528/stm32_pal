STM32
第三章
NVIC
嵌套中断向量表，给中断配置优先级用的

EXTI
1.可以检测信号跳变，产生中断（使用了exti以后就不用将按键检测放到while里了）
2.GPIO，AFIO这些片上外设不具备产生中断的能力
3.exti产生了中断不会清楚，需要手动清楚标志位

EXTI实现按键中断
gpio-afio-exti-nvic
1配置GPIO
2.配置AFIO（将gpio引脚配置到exti线上）
3.配置EXTI（中断是在这产生的，不是在NVIC）
4.配置NVIC（中断优先级）
5.编写中断服务函数

3.6
标准库编程的不足：编程过程琐碎
3.7
EXTI产生的中断是电平型的，因为中断挂起寄存器将脉冲转换成了电平
EXTI一共有20个中断源
AFIO用来配置EXTI的IO口映射的编程接口是GPIO_EXTILineConfig();

第三张 中断编程
单片机编程原则

多任务编程：实时操作系统，裸机多任务模型

裸机多任务模型：对任务进行切片，切的越细越好


串口通信
串口传输先传输低位，在传输高位，书写的时候反着写左边高位右边低位，串口通信传输一个数据帧可以位8/9bit
数据位和校验位可以是 8+0  7+1  9+0  8+1

奇偶校验规则（查询数据中1的个数）
奇校验：判断数据位中1的个数是不是奇数，如果不是奇数，那么校验位为1，这样就是奇数个1了
偶校验：判断数据位中1的个数是不是偶数，如果不是偶数，那么校验位为1，这样就是偶数个1了

停止位的长度是可以选择的 0.5 1 1.5 2

一个字节是8位的，也就是用两个十六进制数字表示，例如0x5b，一个8位字节的二进制数最多有255种可能

连续发送：发送hello，将每个字母拆成ascii码，也就是发送0x48 0x65 0x6c 0x6c  0x6f
连续发送时没有空闲状态，停止位结束后紧接着发送起始位

同步通信：收发双方共享时钟
异步通信：收发双方不共享时钟，收发双方通过波特率来协调通信
波特率：每秒钟传输码元的个数（这里码元就是bit），当波特率为9600时，单个码元的宽度为1/9600s = 0.104ms
硬件流控：a向b传输数据，b向a传输流控信号，只有a收到信号后才会继续发送数据
串口流控的工作原理：cts：可以发送  rts:请求发送，接收方的rts向发送方的cts发送流控信号，信号低电平有效，高电平代表忙

USART
通用同步异步接收器发射器
并行写入 并行读取 串行发送 串行接受
移位寄存器：移位寄存器每动作一次所有比特位向右移动一位
TDR：发送数据寄存器
RDR：接受数据寄存器
CR：配置寄存器
SR：状态寄存器
BRR：波特率寄存器
IER：中断使能寄存器

数据发送过程
使用双缓冲实现连续发送
发送数据过程中的问题
问题1：数据发送过快到时覆盖问题？
TXE：发送寄存器为空 1:为空 0:不为空
每次向TDR写入数据前查询TXE寄存器
问题2：数据什么时候发送完成的问题？
TC：发送完成寄存器 当TDR和移位寄存器都为空时，TC为1，表示发送完成

接受数据过程中的问题
 问题1：什么时候读取数据？
读取RXNE寄存器，当RXNE寄存器为1时， RDR寄存器有数据，这时就可以读取数据

错误标志位
PE：奇偶校验错误
FE：帧格式错误  未收到停止位
NE：噪声错误  接收方一般会采用更高频率去过采样数据，如果在一个码元内因为由噪声干扰造成无法判断01，这时NE寄存器就为1
ORE： 过载错误  接收数据时，没有将RDR寄存器数据及时读出，造成数据被覆盖

错误标志位的使用方法（见截图）
需要先对SR寄存器进行读取备份，因为SR寄存器表示当前状态，把RDR数据读出来以后，SR寄存器就会改变
USART_SendData（）接口中的Data为什么是uint16_t ？ 因为数据位有可能是9位，这样uint8_t就无法存放进去了。
USART_GetFlagStatus可以查询标志位的值

全双工/半双工：是否可以同时发送和接收数据
同步/异步：是否有CK时钟同步信号

